import java.lang.reflect.Array;
import java.util.ArrayList;

public class Apl {

	private static int aantalGetallen = 1000;
	private static int[] heleGetallen;
	private static ArrayList<Integer> gesorteerdeLijst = new ArrayList<Integer>(
			aantalGetallen);

	public static void main(String[] args) {

		heleGetallen = new int[aantalGetallen];
		gesorteerdeLijst = new ArrayList<Integer>(aantalGetallen);

		heleGetallen = vulArray(heleGetallen, aantalGetallen);

		for (int j = 0; j < aantalGetallen; j++) {
			gesorteerdeLijst.add(0);
		}

		opdracht1(heleGetallen);

		opdracht2();

		// System.out.println(gesorteerdeLijst.toString());
		// for (int i = 0; i < heleGetallen.length; i++) {
		// System.out.print(heleGetallen[i] + ", ");
		// }
	}

	/**
	 * Methode voor het vullen van de array met willekeurige hele getallen.
	 */
	public static int[] vulArray(int[] array, int aantalGetallen) {
		for (int i = 0; i < aantalGetallen; i++) {

			// random getal tussen 0 en 100
			int getal = randInt(0, 100);

			array[i] = getal;
		}
		return array;
	}

	/**
	 * Methode voor het genereren van een radom getal tussen twee grenzen.
	 * 
	 * @param min
	 *            - ondergrens
	 * @param max
	 *            - bovengrens
	 * @return het gegenereerde random getal
	 */
	public static int randInt(int min, int max) {
		assert min < max : "Het maximum is kleiner dan het minimum";

		return min + (int) (Math.random() * max);
	}

	public static void opdracht1(int[] array) {
		Thread is = new InsertionSort(array, gesorteerdeLijst);
		is.start();
	}

	public static void opdracht2() {
	
		int n = aantalGetallen / 2;

		int[] a1 = new int[n];
		int[] a2 = new int[n];
		a2 = vulArray(a2, n);
		a1 = vulArray(a1, n);

		ArrayList<Integer> list1 = new ArrayList<Integer>();
		ArrayList<Integer> list2 = new ArrayList<Integer>();

		for (int j = 0; j < (n); j++) {
			list1.add(0);
			list2.add(0);
		}

		Thread t1 = new InsertionSort(a1, list1);
		Thread t2 = new InsertionSort(a2, list2);
		t1.start();
		t2.start();

		try {
			t1.join();
			t2.join();
		} catch (InterruptedException e) {
		}
		
		assert list1.size() == n : "wrong size list 1" + list1.size();
		
		ArrayList<Integer> result = new ArrayList<Integer>();
		
		int index1 = 0;
		int index2 = 0;
		System.out.println(list1.size() + list2.size());
		
		for(int i = 0; i < (list1.size() + list2.size()); i++) {
			
			if(list1.get(index1) < list2.get(index2)) {
				result.add(list1.get(index1));
				if(index1 + 1 < list1.size()){
					index1++;
				}
			} else {
				result.add(list2.get(index2));
				if(index2 + 1 < list2.size()){
					index2++;
				}
			}
		}
		
		System.out.println(result.toString());

	}

	public static void opdracht3() {

	}
	
	public static void insertionSort(int[] array) {
		for (int i = 1; i < array.length; i++) {
			int getal = array[i];
			int x;
			for (x = i; x > 0 && getal < array[x - 1]; x--) {
				array[x] = array[x - 1];
			}
			array[x] = getal;
		}
	}

	private static <AnyType extends Comparable<? super AnyType>> void merge(
			AnyType[] a, AnyType[] tmpArray, int leftPos, int rightPos,
			int rightEnd) {
		int leftEnd = rightPos - 1;
		int tmpPos = leftPos;
		int numElements = rightEnd - leftPos + 1;
		while (leftPos <= leftEnd && rightPos <= rightEnd)
			// Main loop
			if (a[leftPos].compareTo(a[rightPos]) <= 0)
				tmpArray[tmpPos++] = a[leftPos++];
			else
				tmpArray[tmpPos++] = a[rightPos++];
		while (leftPos <= leftEnd)
			// Copy rest of first half
			tmpArray[tmpPos++] = a[leftPos++];
		while (rightPos <= rightEnd)
			// Copy rest of right half
			tmpArray[tmpPos++] = a[rightPos++];
		for (int i = 0; i < numElements; i++, rightEnd--)
			// Copy tmpArray back
			a[rightEnd] = tmpArray[rightEnd];
	}

	/**
	 * Internal method that makes recursive calls.
	 * 
	 * @param aan array of Comparable items.
	 * @param tmpArray an array to place the merged result.
	 * @param left the left-most index of the subarray.
	 * @param right the right-most index of the subarray.
	 */
	private static <AnyType extends Comparable<? super AnyType>> void mergeSort(
			AnyType[] a, AnyType[] tmpArray, int left, int right) {
		if (left < right) {
			int center = (left + right) / 2;
			mergeSort(a, tmpArray, left, center);
			mergeSort(a, tmpArray, center + 1, right);
			merge(a, tmpArray, left, center + 1, right);
		}
	}

}
